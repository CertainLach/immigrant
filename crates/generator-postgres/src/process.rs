use std::collections::{BTreeMap, BTreeSet};

use schema::{
	index::{Constraint, ConstraintTy},
	parser::{self, ParsingError},
	root::{Item, Schema, SchemaProcessOptions},
	scalar::{Scalar, ScalarAnnotation},
	sql::{Sql, SqlOp},
	table::{Table, TableAnnotation},
	w,
};

use crate::Pg;

fn default_options() -> SchemaProcessOptions {
	SchemaProcessOptions {
		generator_supports_domain: true,
	}
}

/// First generate names, because only check constraint are mergeable, and there is no problem with merging unrelated
/// constraints, then merge constraints with the same name.
impl Pg<&mut Scalar> {
	/// In postgres, first check constraint has autogenerated `table_check` name, second is `table_check1` and so on.
	/// In immigrant, constraints with the same name are merged, so only name we should save to every constraint is
	/// `table_check`
	pub fn generate_names(&mut self) {
		let name = self.name();
		for ann in &mut self.annotations {
			match ann {
				ScalarAnnotation::Constraint(c) if c.name.is_none() => {
					if let ConstraintTy::Check { .. } = &c.kind {
						c.name = Some(format!("{name}_check"));
					}
				}
				_ => {}
			}
		}
	}
	/// All checks with the same name are merged using AND
	pub fn merge_checks(&mut self) {
		let mut merged = <BTreeMap<String, Vec<_>>>::new();
		let mut dropped = vec![];
		for (i, ann) in self.annotations.iter_mut().enumerate() {
			if let ScalarAnnotation::Constraint(c) = ann {
				if let ConstraintTy::Check { sql } = &c.kind {
					let checks = merged
						.entry(c.name.as_ref().expect("set").to_owned())
						.or_default();
					checks.push(sql.clone());
					dropped.push(i);
				}
			}
		}
		for id in dropped.into_iter().rev() {
			self.annotations.remove(id);
		}
		for (name, value) in merged {
			self.annotations
				.push(ScalarAnnotation::Constraint(Constraint {
					kind: ConstraintTy::Check {
						sql: {
							let mut values = value.into_iter();
							let mut out = values.next().expect("at least one");
							for value in values {
								out = Sql::BinOp(Box::new(out), SqlOp::And, Box::new(value));
							}
							out
						},
					},
					name: Some(name),
				}))
		}
	}
}

/// First merge constraints, to allow specifying partial primary keys, i.e
/// ```immigrant
/// a @primary_key;
/// b @primary_key;
/// c @primary_key;
/// ```
///
/// Should be equivalent to
/// ```immigrant
/// a;
/// b;
/// c;
/// @primary_key(a, b, c)
/// ```
///
/// Then generate names, i.e for the specified example it will be `table_a_b_c_pk`
impl Pg<&mut Table> {
	/// Merge annotations:
	/// - Primary keys are merged by name (either some or none), even if it makes little sense -
	///   post-validation should forbid multiple primary keys
	/// - Checks with the same name (+unnamed) are merged using AND
	/// - Unique constraints are merged the same way as the primary key, but unnamed uniques are not merged
	/// - Indexes are merged the same way as unique constraints, except accounting for the uniqueness flag
	pub fn merge(&mut self) {
		let mut removed = BTreeSet::new();
		let mut added = vec![];
		for (i, ann) in self.annotations.iter().enumerate() {
			if !removed.insert(i) {
				continue;
			}
			match ann {
				TableAnnotation::Constraint(c) => match &c.kind {
					ConstraintTy::PrimaryKey(pk) => {
						let mut full_set = pk.clone();
						for (j, merge) in self
							.annotations
							.iter()
							.enumerate()
							.filter_map(|(ii, v)| Some((ii, TableAnnotation::as_constraint(v)?)))
							.filter(|(_, cons)| cons.name == c.name)
						{
							match &merge.kind {
								ConstraintTy::PrimaryKey(p) => {
									if !removed.insert(j) {
										continue;
									}
									full_set.extend(p.iter().cloned());
								}
								_ => continue,
							}
						}
						added.push(TableAnnotation::Constraint(Constraint {
							name: c.name.clone(),
							kind: ConstraintTy::PrimaryKey(full_set),
						}))
					}
					ConstraintTy::Unique { columns } => {
						let mut full_set = columns.clone();
						for (j, merge) in self
							.annotations
							.iter()
							.enumerate()
							.filter_map(|(ii, v)| Some((ii, TableAnnotation::as_constraint(v)?)))
							.filter(|(_, cons)| cons.name.is_some() && cons.name == c.name)
						{
							match &merge.kind {
								ConstraintTy::Unique { columns: p } => {
									if !removed.insert(j) {
										continue;
									}
									full_set.extend(p.iter().cloned());
								}
								_ => continue,
							}
						}
						added.push(TableAnnotation::Constraint(Constraint {
							name: c.name.clone(),
							kind: ConstraintTy::Unique { columns: full_set },
						}))
					}
					ConstraintTy::Check { sql } => {
						let mut out = sql.clone();
						for (j, merge) in self
							.annotations
							.iter()
							.enumerate()
							.filter_map(|(ii, v)| Some((ii, TableAnnotation::as_constraint(v)?)))
							.filter(|(_, cons)| cons.name == c.name)
						{
							match &merge.kind {
								ConstraintTy::Check { sql: p } => {
									if !removed.insert(j) {
										continue;
									}
									out =
										Sql::BinOp(Box::new(out), SqlOp::And, Box::new(p.clone()));
								}
								_ => continue,
							}
						}
						added.push(TableAnnotation::Constraint(Constraint {
							name: c.name.clone(),
							kind: ConstraintTy::Check { sql: out },
						}))
					}
				},
				TableAnnotation::Index(i) => {
					let mut out = i.clone();
					for (j, merge) in self
						.annotations
						.iter()
						.enumerate()
						.filter_map(|(j, v)| Some((j, v.as_index()?)))
					{
						if i.unique != merge.unique {
							continue;
						}
						if i.name.is_none() || i.name != merge.name {
							continue;
						}
						if !removed.insert(j) {
							continue;
						}
						out.fields.extend(merge.fields.iter());
					}
					added.push(TableAnnotation::Index(out))
				}
			}
		}
		for i in removed.iter().rev() {
			self.annotations.remove(*i);
		}
		self.annotations.extend(added);
	}
	pub fn generate_names(&mut self) {
		let mut decided_names = Vec::new();
		for ann in self.annotations.iter() {
			match ann {
				TableAnnotation::Index(i) if i.name.is_none() => {
					let mut out = self.name().to_string();
					w!(out, "_");
					for column in self.db_names(i.fields.iter().cloned()) {
						w!(out, "{column}_");
					}
					if i.unique {
						w!(out, "key")
					} else {
						w!(out, "idx")
					}
					decided_names.push(Some(out));
				}
				TableAnnotation::Constraint(c) if c.name.is_none() => {
					let mut out = self.name().to_string();
					w!(out, "_");
					let columns = match &c.kind {
						ConstraintTy::PrimaryKey(c) => c.clone(),
						ConstraintTy::Unique { columns } => columns.clone(),
						ConstraintTy::Check { sql } => sql.affected_columns(),
					};
					for column in self.db_names(columns.iter().cloned()) {
						w!(out, "{column}_");
					}
					match &c.kind {
						ConstraintTy::PrimaryKey(_) => w!(out, "pkey"),
						ConstraintTy::Unique { .. } => w!(out, "key"),
						ConstraintTy::Check { .. } => w!(out, "check"),
					}
					decided_names.push(Some(out))
				}
				_ => decided_names.push(None),
			}
		}
		assert_eq!(decided_names.len(), self.annotations.len());
		for (i, ann) in self.annotations.iter_mut().enumerate() {
			let name = decided_names[i].clone();
			match ann {
				TableAnnotation::Index(i) if i.name.is_none() => {
					assert!(name.is_some());
					i.name = name;
				}
				TableAnnotation::Constraint(c) if c.name.is_none() => {
					assert!(name.is_some());
					c.name = name;
				}
				_ => assert!(name.is_none()),
			}
		}
	}
}

fn process(schema: &mut Schema) {
	for item in &mut schema.0 {
		if let Item::Scalar(s) = item {
			let mut s = Pg(s);
			s.generate_names();
			s.merge_checks();
		} else if let Item::Table(t) = item {
			let mut t = Pg(t);
			t.merge();
			t.generate_names();
		}
	}
}

pub fn parse(s: &str) -> Result<Schema, Vec<ParsingError>> {
	let mut schema = parser::parse(s, &default_options())?;
	process(&mut schema);
	Ok(schema)
}
