use std::{
	collections::BTreeMap,
	mem,
	ops::{Deref, DerefMut},
};

use itertools::{Either, Itertools};

use crate::{
	index::{Check, Index, PrimaryKey, UniqueConstraint},
	root::{Item, Schema},
	scalar::{Scalar, ScalarAnnotation},
	sql::Sql,
	table::{Table, TableAnnotation},
	w,
};

pub enum NamingConvention {
	Postgres,
}

pub struct Pgnc<T>(pub T);
impl<T> Deref for Pgnc<T> {
	type Target = T;
	fn deref(&self) -> &Self::Target {
		&self.0
	}
}
impl<T> DerefMut for Pgnc<T> {
	fn deref_mut(&mut self) -> &mut Self::Target {
		&mut self.0
	}
}

impl Pgnc<&mut Schema> {
	pub fn process_naming(&mut self) {
		for item in self.0 .0.iter_mut() {
			match item {
				Item::Table(t) => {
					let mut t = Pgnc(t);
					t.merge();
					t.generate_names();
				}
				Item::Scalar(s) => {
					let mut s = Pgnc(s);
					s.generate_names();
					s.merge_checks();
				}
				Item::Enum(_) => {}
			}
		}
	}
}

/// First generate names, because only check constraint are mergeable, and there is no problem with merging unrelated
/// constraints, then merge constraints with the same name.
impl Pgnc<&mut Scalar> {
	/// In postgres, first check constraint has autogenerated `table_check` name, second is `table_check1` and so on.
	/// In immigrant, constraints with the same name are merged, so only name we should save to every constraint is
	/// `table_check`
	pub fn generate_names(&mut self) {
		let name = self.name();
		for ann in &mut self.annotations {
			if let ScalarAnnotation::Check(c) = ann {
				if c.name.is_some() {
					continue;
				}
				c.name = Some(format!("{name}_check"));
			}
		}
	}
	/// All checks with the same name are merged using AND
	pub fn merge_checks(&mut self) {
		// let mut merged = <BTreeMap<String, Vec<_>>>::new();
		let (checks, mut annotations): (Vec<_>, Vec<_>) = mem::take(&mut self.annotations)
			.into_iter()
			.partition_map(|a| match a {
				ScalarAnnotation::Check(c) => Either::Left(c),
				a => Either::Right(a),
			});
		let merged_checks = checks
			.into_iter()
			.map(|c| (c.name.expect("name is assigned"), c.check))
			.into_group_map()
			.into_iter()
			.collect::<BTreeMap<_, _>>();
		for (name, checks) in merged_checks {
			annotations.push(ScalarAnnotation::Check(Check {
				name: Some(name),
				check: Sql::all(checks),
			}))
		}
		self.annotations = annotations;
	}
}

/// First merge constraints, to allow specifying partial primary keys, i.e
/// ```immigrant
/// a @primary_key;
/// b @primary_key;
/// c @primary_key;
/// ```
///
/// Should be equivalent to
/// ```immigrant
/// a;
/// b;
/// c;
/// @primary_key(a, b, c)
/// ```
///
/// Then generate names, i.e for the specified example it will be `table_a_b_c_pk`
impl Pgnc<&mut Table> {
	/// Merge annotations:
	/// - Primary keys are always merged, it is assumed at most only name will be set.
	/// - Checks with the same name (+all unnamed) are merged using AND
	/// - Unique constraints are merged the same way as the primary key, but unnamed uniques are not merged
	/// - Indexes are merged the same way as unique constraints, except accounting for the uniqueness flag
	pub fn merge(&mut self) {
		let annotations = mem::take(&mut self.annotations);

		// PK
		let pk_name = annotations
			.iter()
			.filter_map(TableAnnotation::as_primary_key)
			.filter_map(|pk| pk.name.clone())
			.at_most_one()
			.expect("at most one pk have name set");
		let (pks, mut annotations): (Vec<_>, Vec<_>) =
			annotations.into_iter().partition_map(|a| match a {
				TableAnnotation::PrimaryKey(pk) => Either::Left(pk),
				a => Either::Right(a),
			});
		annotations.push(TableAnnotation::PrimaryKey(PrimaryKey {
			name: pk_name,
			columns: pks.into_iter().flat_map(|pk| pk.columns).collect(),
		}));

		// Unique
		let (unqs, mut annotations): (Vec<_>, Vec<_>) =
			annotations.into_iter().partition_map(|a| match a {
				TableAnnotation::Unique(u) => Either::Left(u),
				a => Either::Right(a),
			});
		let (named_unqs, unnamed_unqs) = unqs
			.into_iter()
			.partition::<Vec<_>, _>(|u| u.name.is_some());
		let named_unqs = named_unqs
			.into_iter()
			.map(|u| (u.name.expect("has name"), u.columns))
			.into_group_map()
			.into_iter()
			.collect::<BTreeMap<_, _>>();
		for (name, cols) in named_unqs {
			annotations.push(TableAnnotation::Unique(UniqueConstraint {
				name: Some(name),
				columns: cols.into_iter().flatten().collect(),
			}))
		}
		for unq in unnamed_unqs {
			annotations.push(TableAnnotation::Unique(unq));
		}

		// Check
		let (checks, mut annotations): (Vec<_>, Vec<_>) =
			annotations.into_iter().partition_map(|a| match a {
				TableAnnotation::Check(c) => Either::Left(c),
				a => Either::Right(a),
			});
		let (named_cks, unnamed_cks) = checks
			.into_iter()
			.partition::<Vec<_>, _>(|c| c.name.is_some());
		let named_cks = named_cks
			.into_iter()
			.map(|c| (c.name.expect("has name"), c.check))
			.into_group_map()
			.into_iter()
			.collect::<BTreeMap<_, _>>();
		for (name, checks) in named_cks {
			annotations.push(TableAnnotation::Check(Check {
				name: Some(name),
				check: Sql::all(checks),
			}))
		}
		annotations.push(TableAnnotation::Check(Check {
			name: None,
			check: Sql::all(unnamed_cks.into_iter().map(|c| c.check)),
		}));

		// Index
		let (indexes, mut annotations): (Vec<_>, Vec<_>) =
			annotations.into_iter().partition_map(|a| match a {
				TableAnnotation::Index(i) => Either::Left(i),
				a => Either::Right(a),
			});
		let (named_idxs, unnamed_idxs) = indexes
			.into_iter()
			.partition::<Vec<_>, _>(|i| i.name.is_some());
		// let (unique_idxs, normal_idxs) =
		// 	named_idxs.into_iter().partition::<Vec<_>, _>(|i| i.unique);
		// let unique_idxs = na
		let named_idxs = named_idxs
			.into_iter()
			.map(|i| ((i.unique, i.name.expect("has name")), i.fields))
			.into_group_map()
			.into_iter()
			.collect::<BTreeMap<_, _>>();
		for ((unique, name), fields) in named_idxs {
			annotations.push(TableAnnotation::Index(Index {
				name: Some(name),
				unique,
				fields: fields.into_iter().flatten().collect(),
			}))
		}
		for idx in unnamed_idxs {
			annotations.push(TableAnnotation::Index(idx))
		}
	}
	pub fn generate_names(&mut self) {
		let mut decided_names = Vec::new();
		for ann in self.annotations.iter() {
			match ann {
				TableAnnotation::Index(i) if i.name.is_none() => {
					let mut out = self.name().to_string();
					w!(out, "_");
					for column in self.db_names(i.fields.iter().cloned()) {
						w!(out, "{column}_");
					}
					if i.unique {
						w!(out, "key")
					} else {
						w!(out, "idx")
					}
					decided_names.push(Some(out));
				}
				TableAnnotation::Check(c) if c.name.is_none() => {
					let mut out = self.name().to_string();
					w!(out, "_");
					for ele in self.db_names(c.check.affected_columns()) {
						w!(out, "{ele}_");
					}
					w!(out, "check");
					decided_names.push(Some(out));
				}
				TableAnnotation::Unique(u) if u.name.is_none() => {
					let mut out = self.name().to_string();
					w!(out, "_");
					for ele in self.db_names(u.columns.iter().cloned()) {
						w!(out, "{ele}_");
					}
					w!(out, "_key");
					decided_names.push(Some(out));
				}
				TableAnnotation::PrimaryKey(p) if p.name.is_none() => {
					let mut out = self.name().to_string();
					w!(out, "_");
					for ele in self.db_names(p.columns.iter().cloned()) {
						w!(out, "{ele}_");
					}
					w!(out, "_pkey");
					decided_names.push(Some(out));
				}
				_ => decided_names.push(None),
			}
		}
		assert_eq!(decided_names.len(), self.annotations.len());
		for (i, ann) in self.annotations.iter_mut().enumerate() {
			let name = decided_names[i].clone();
			match ann {
				TableAnnotation::Index(i) if i.name.is_none() => {
					assert!(name.is_some());
					i.name = name;
				}
				_ => assert!(name.is_none()),
			}
		}
	}
}
