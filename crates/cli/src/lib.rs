use std::{
	fs,
	path::{Path, PathBuf},
};

use anyhow::anyhow;
use ass_stroke::{SnippetBuilder, Text};
use file_diffs::{Migration, MigrationId};
use generator_postgres::Pg;
use schema::{
	parser,
	process::NamingConvention,
	root::{Schema, SchemaProcessOptions},
	uid::RenameMap,
};

pub fn parse_schema(schema: &str, rn: &mut RenameMap) -> anyhow::Result<Schema> {
	match parser::parse(
		schema,
		&SchemaProcessOptions {
			generator_supports_domain: true,
			naming_convention: NamingConvention::Postgres,
		},
		rn,
	) {
		Ok(s) => Ok(s),
		Err(e) => {
			let mut builder = SnippetBuilder::new(schema);
			for e in e {
				match e {
					parser::ParsingError::Peg(peg) => {
						builder
							.error(Text::single(
								format!("parsing error: {peg}").chars(),
								Default::default(),
							))
							.range(peg.location.offset..=peg.location.offset)
							.build();
					}
				}
			}
			eprintln!("schema parsing ended with failure:");
			eprint!("{}", ass_stroke::source_to_ansi(&builder.build()));
			Err(anyhow!("failed to parse schema"))
		}
	}
}

pub fn current_schema(dir: &Path) -> anyhow::Result<(String, Schema, RenameMap)> {
	let mut name = dir.to_path_buf();
	name.push("db.schema");
	let schema_str = fs::read_to_string(&name)?;
	let mut rn = RenameMap::default();
	let schema = parse_schema(&schema_str, &mut rn)?;
	generator_postgres::validate::validate(&schema_str, &schema, &rn);
	Ok((schema_str, schema, rn))
}

pub fn stored_schema(
	list: &[(MigrationId, Migration, PathBuf)],
) -> anyhow::Result<(String, Schema, RenameMap)> {
	let mut schema_str = String::new();
	for (_, migration, _) in list {
		schema_str = migration.apply_diff(schema_str)?;
	}
	let mut rn = RenameMap::default();
	let schema = parse_schema(&schema_str, &mut rn)?;
	Ok((schema_str, schema, rn))
}

fn decorate_automatically_generated(text: &mut String, has_before: bool, has_after: bool) {
	if !has_before && !has_after {
		text.insert_str(0, "-- THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT\n")
	} else if !has_after {
		text.insert_str(
			0,
			"-- THE REST OF THE FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT\n",
		)
	} else {
		text.insert_str(0, "-- BEGIN OF AUTOMATICALLY GENERATED, DO NOT EDIT!\n");
		text.push_str("\n-- END OF AUTOMATICALLY GENERATED");
	}
}
fn decorate_before(text: &mut String, before: &str) {
	if before.is_empty() {
		return;
	}
	text.insert_str(0, "\n-- END OF USER ADDED\n\n");
	text.insert_str(0, before);
	text.insert_str(
		0,
		"-- BEGIN OF USER ADDED, DO NOT EDIT, UPDATE db.update INSTEAD!\n",
	);
}
fn decorate_after(text: &mut String, after: &str) {
	if after.is_empty() {
		return;
	}
	text.push_str("\n\n-- BEGIN OF USER ADDED, DO NOT EDIT, UPDATE db.update INSTEAD\n");
	text.push_str(after);
	text.push_str("\n-- END OF USER ADDED");
}

pub fn generate_sql_nowrite(
	migration: &Migration,
	old_schema: &Schema,
	new_schema: &Schema,
	rn: &RenameMap,
) -> anyhow::Result<(String, String)> {
	let mut up = String::new();
	let mut down = String::new();
	Pg(new_schema).diff(&Pg(old_schema), &mut up, &mut rn.clone());
	Pg(old_schema).diff(&Pg(new_schema), &mut down, &mut rn.clone());

	decorate_automatically_generated(
		&mut up,
		!migration.before_up_sql.is_empty(),
		!migration.after_up_sql.is_empty(),
	);
	decorate_automatically_generated(
		&mut down,
		!migration.before_down_sql.is_empty(),
		!migration.after_down_sql.is_empty(),
	);
	decorate_before(&mut up, &migration.before_up_sql);
	decorate_before(&mut down, &migration.before_down_sql);
	decorate_after(&mut up, &migration.after_up_sql);
	decorate_after(&mut down, &migration.after_down_sql);
	Ok((up, down))
}
pub fn generate_sql(
	migration: &Migration,
	old_schema: &Schema,
	new_schema: &Schema,
	rn: &RenameMap,
	out: &Path,
) -> anyhow::Result<()> {
	let (up, down) = generate_sql_nowrite(migration, old_schema, new_schema, rn)?;

	let mut out = out.to_path_buf();
	out.push("up.sql");
	fs::write(&out, up.as_bytes())?;
	out.pop();
	out.push("down.sql");
	fs::write(&out, down.as_bytes())?;
	Ok(())
}
