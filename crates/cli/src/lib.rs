use std::{
	fs,
	path::{Path, PathBuf},
};

use anyhow::{anyhow, bail};
use file_diffs::{Migration, MigrationId};
use generator_postgres::Pg;
use hi_doc::{SnippetBuilder, Text};
use schema::{
	diagnostics::Report,
	parser,
	process::NamingConvention,
	root::{Schema, SchemaProcessOptions},
	uid::RenameMap,
};

pub fn parse_schema(
	schema: &str,
	compat: bool,
	rn: &mut RenameMap,
) -> anyhow::Result<(Schema, Report)> {
	let mut report = Report::new();
	let s = parser::parse(
		schema,
		compat,
		&SchemaProcessOptions {
			generator_supports_domain: true,
			naming_convention: NamingConvention::Postgres,
		},
		rn,
		&mut report,
	);
	if report.is_error() && s.is_err() {
		eprintln!("schema parsing ended with failure:");
		for s in report.to_hi_doc(schema) {
			eprint!("{}", hi_doc::source_to_ansi(&s));
		}
		return Err(anyhow!("failed to parse schema"));
	}
	Ok((s.expect("reports are returned using report"), report))
}

pub fn current_schema(dir: &Path) -> anyhow::Result<(String, Schema, Report, RenameMap)> {
	let mut name = dir.to_path_buf();
	name.push("db.schema");
	let schema_str = fs::read_to_string(&name)?;
	let mut rn = RenameMap::default();
	let (schema, report) = parse_schema(&schema_str, false, &mut rn)?;
	generator_postgres::validate::validate(&schema_str, &schema, &rn);
	Ok((schema_str, schema, report, rn))
}

pub fn stored_schema(
	list: &[(MigrationId, Migration, PathBuf)],
) -> anyhow::Result<(String, Schema, Report, RenameMap)> {
	let mut schema_str = String::new();
	for (_, migration, _) in list {
		schema_str = migration.apply_diff(schema_str)?;
	}
	let mut rn = RenameMap::default();
	let (schema, report) = parse_schema(&schema_str, false, &mut rn)?;
	Ok((schema_str, schema, report, rn))
}

fn decorate_automatically_generated(text: &mut String, has_before: bool, has_after: bool) {
	if !has_before && !has_after {
		text.insert_str(0, "-- THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT\n")
	} else if !has_after {
		text.insert_str(
			0,
			"-- THE REST OF THE FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT\n",
		)
	} else {
		text.insert_str(0, "-- BEGIN OF AUTOMATICALLY GENERATED, DO NOT EDIT!\n");
		text.push_str("\n-- END OF AUTOMATICALLY GENERATED");
	}
}
fn decorate_before(text: &mut String, before: &str) {
	if before.is_empty() {
		return;
	}
	text.insert_str(0, "\n-- END OF USER ADDED\n\n");
	text.insert_str(0, before);
	text.insert_str(
		0,
		"-- BEGIN OF USER ADDED, DO NOT EDIT, UPDATE db.update INSTEAD!\n",
	);
}
fn decorate_after(text: &mut String, after: &str) {
	if after.is_empty() {
		return;
	}
	text.push_str("\n\n-- BEGIN OF USER ADDED, DO NOT EDIT, UPDATE db.update INSTEAD\n");
	text.push_str(after);
	text.push_str("\n-- END OF USER ADDED");
}

pub fn generate_sql_nowrite(
	migration: &Migration,
	old_schema: &Schema,
	new_schema: &Schema,
	rn: &RenameMap,
	report_old: &mut Report,
	report_new: &mut Report,
) -> anyhow::Result<(String, String)> {
	let mut up = String::new();
	let mut down = String::new();
	Pg(new_schema).diff(
		&Pg(old_schema),
		&mut up,
		&mut rn.clone(),
		report_old,
		report_new,
	);
	Pg(old_schema).diff(
		&Pg(new_schema),
		&mut down,
		&mut rn.clone(),
		report_new,
		report_old,
	);

	decorate_automatically_generated(
		&mut up,
		!migration.before_up_sql.is_empty(),
		!migration.after_up_sql.is_empty(),
	);
	decorate_automatically_generated(
		&mut down,
		!migration.before_down_sql.is_empty(),
		!migration.after_down_sql.is_empty(),
	);
	decorate_before(&mut up, &migration.before_up_sql);
	decorate_before(&mut down, &migration.before_down_sql);
	decorate_after(&mut up, &migration.after_up_sql);
	decorate_after(&mut down, &migration.after_down_sql);
	Ok((up, down))
}
pub fn generate_sql(
	migration: &Migration,
	old_src: &str,
	new_src: &str,
	old_schema: &Schema,
	new_schema: &Schema,
	rn: &RenameMap,
	out: &Path,
	mut report_old: Report,
	mut report_new: Report,
) -> anyhow::Result<()> {
	let (up, down) = generate_sql_nowrite(
		migration,
		old_schema,
		new_schema,
		rn,
		&mut report_old,
		&mut report_new,
	)?;

	if display_reports(old_src, new_src, report_old, report_new) {
		bail!("errors are reported, cannot continue");
	}

	let mut out = out.to_path_buf();
	out.push("up.sql");
	fs::write(&out, up.as_bytes())?;
	out.pop();
	out.push("down.sql");
	fs::write(&out, down.as_bytes())?;
	Ok(())
}

pub fn display_reports(a: &str, b: &str, ar: Report, br: Report) -> bool {
	if ar.is_error() || br.is_error() {
		eprintln!("schema diffing ended with failure:");
		for s in ar.to_hi_doc(a) {
			eprint!("{}", hi_doc::source_to_ansi(&s));
		}
		for s in br.to_hi_doc(b) {
			eprint!("{}", hi_doc::source_to_ansi(&s));
		}
		true
	} else {
		false
	}
}
