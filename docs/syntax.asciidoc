
= My Schema Language
:toc: right

== Introduction

This document provides a brief overview of the syntax of the schema language.

== Schema Structure

A schema is composed of various items, including tables, enums, and scalars.

=== Table

A table is defined using the `table` keyword. It must include a name and may also include columns, annotations, and foreign keys.

[source,plaintext]
----
table TableName {
    column1: type;
    column2: type;
    @annotation;
    foreignKey;
}
----

=== Enum

An enum is defined using the `enum` keyword. It must include a name and a list of items.

[source,plaintext]
----
enum EnumName {item1; item2;}
----

== Scalars

A scalar represents a primitive type in the database. It is defined with a keyword `scalar`, followed by an identifier and the corresponding database type in quotes. Additionally, scalars can have annotations `@default` and `@check`.

[source,plaintext]
----
// A scalar named "my_integer" that corresponds to the "int" type in the database.
// It has a default value of 0.
scalar my_integer "int" @default(0);

// A scalar named "positive_integer" that corresponds to the "int" type in the database.
// It has a check constraint that ensures the value is positive.
scalar positive_integer "int" @check(_ > 0);

// A scalar named "limited_string" that corresponds to the "varchar(255)" type in the database.
// It has a default value of an empty string.
scalar limited_string "varchar(255)" @default("");

// A scalar named "future_date" that corresponds to the "date" type in the database.
// It has a check constraint that ensures the date is in the future.
scalar future_date "date" @check(_ > now());
----

== Annotations

Annotations are used to modify the behavior of columns, scalars, or tables. They are prefixed with the `@` symbol.

[source,plaintext]
----
@ColumnName @annotation;
----

== SQL Expressions

SQL expressions can be used in default values and check constraints.

[source,plaintext]
----
@default(sql_expression);
----

== Foreign Keys

Foreign keys are used to establish a link between the data in two tables. They are a key field or set of fields in one table, that is used to link to a primary key in another table. 

[source,plaintext]
----
columnName: type ~ TargetTable(targetColumn);
----

In the above example, `columnName` in the current table is a foreign key that references `targetColumn` in `TargetTable`. If `targetColumn` is omitted, it is assumed that the target column has the same name as the source column (`columnName` in this case).

[source,plaintext]
----
example_column: type ~ Table; // Target column is implied to be the same name: example_column
----

Foreign keys can also be defined in a standalone manner, with a full declaration syntax. The declaration includes the source columns in the current table, an optional foreign key name, the target table, and the target columns. 

[source,plaintext]
----
(sourceColumn1, sourceColumn2) "foreignKeyName" ~.onDeleteAction TargetTable(targetColumn1, targetColumn2);
----

In the above example, `sourceColumn1` and `sourceColumn2` in the current table are foreign keys that reference `targetColumn1` and `targetColumn2` in `TargetTable`, respectively. The foreign key is named `foreignKeyName`, and the `onDeleteAction` specifies what action to take when the referenced data in the target table is deleted.

The `onDeleteAction` can be one of the following:

- `.cascade`: Delete or update the row from the parent table and automatically delete or update the matching rows in the child table.
- `.set_null`: Delete or update the row from the parent table and set the foreign key column or columns in the child table to `NULL`.
- `.set_default`: Delete or update the row from the parent table and set the foreign key column or columns in the child table to their default values.
- `.restrict`: Rejects the delete or update operation for the parent table.
- `.noop`: Do nothing.

[source,plaintext]
----
table B{
    a: type; 
    b: type;
    // Standalone fks, full declaration syntax
    (a, b) "fk_name" ~.cascade Table (a, b);
}
----

Note: In the standalone syntax, either source or target columns may be omitted, but not both. If the foreign key name is omitted, it will be generated by the database conventions.
